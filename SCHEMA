The web player and the backend communicate in real time to facilitate video
synchronization. They do this by exchanging JSON messages over the WebSocket API.
This is the schema that describes the messages.

These are described from the perspective of client -> server.
'in' is a message that the server recieves from some client.
Each 'in' message is validated by the server before being handled.

'out' is a message that the server generates and sends to some client/s.
Each 'out' message contains a timestamp that is generated by the server.
The client is intended to intelligently ignore information that comes out
of order by using this timestamp field. Eg if two pause/unpause events
are received, but the second has an earlier timestamp than the first,
the second message should be ignored.

* pause/unpause:
    in = { event: "paused", paused: true/false }

    The client receives no response. 'out' is sent
    to all other clients in the party.

    out = { ...in, timestamp }

* skip to time:
    in = { event: "seek", seek: <seek time in seconds as integer> }

    The client receives no response. 'out' is sent
    to all other clients in the party.

    out = { ...in, timestamp }
    

* play a new video:
    in = { event: "video", video: "nQ2A30cD3Q8" }

    https://www.youtube.com/watch?v=nQ2A30cD3Q8
                in["video"] is this ^^^^^^^^^^^
    The client receives no response. 'out' is sent
    to all other clients in the party.

    out = { ...in, timestamp }

* request all party info:
    in = { event: "info" }

    'out' is sent to the sending client, containing party information
    
    out = { ...in, timestamp, 
            members: [...<client ids as strings>], 
            paused: true/false, 
            video: "nQ2A30cD3Q8",
            seek: 1234
         }
